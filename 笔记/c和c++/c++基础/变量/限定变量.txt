1.语法：
const 数据类型 变量标识符 = 值;
例如：
const int a = 10;

2.限定变量相当于一个常量，编译器在编译时，会把这个变量全部替换为对其赋值的数据，
所以在程序运行时，其实没有这个变量，只有一个数据，所以任何对限定变量赋值的行为
都会引发错误

3.由于编译器对限定变量的处理方式，所以，限定变量必须有一个初始值，限定变量也可以作为
一个值赋给其他对象，并不会使其他对象改变为限定变量

4.默认情况下，编译器的行为，使得限定变量只能在当前文件下使用，其他文件不能使用，如果要在
其他文件中使用，必须在本文件和其他文件中都使用extend声明变量
例如：
extend const int a = 10; 其他文件中使用 extend int a;

5.对限定变量的引用：
const int a = 10; const int &r = a;
对限定变量引用时，引用也必须使用const，否则会报错
引用的限定变量也是一个常量，所以对引用赋值也会引发错误 

6.对限定变量引用的初始化
常量引用仅对引用参与的操作做出了限定，并未对引用对象是不是常量做出限定
int i =42;
const int &r1 = i;正确的，可以接受一个普通对象作为值，引用的是i的值，i的值改变会改变ri的值，但是不能
修改r1的值
const int &r2 = 43;正确的，接受一个常量作为初始值
int &r4 = r1*2;错误的，非限定变量引用，不能使用常量值作为初始值
double d = 3.14;
const int &r = d;此时会产生一个临时变量int temp = 3; const int &r = temp;r引用的是temp

7.指向常量的指针与常量指针
int i = 10; const int *p = i;指向常量的指针，不能用*p改变对象的值，对象的值改变，*p的值也会改变，
但是可以给p重新赋予一个对象
int i = 10;int *const p = i;常量指针，可以通过*p改变对象的值，但是不能给p重新赋值另一个对象，p保存的
对象的地址值一直不会变
int i = 10;const int *const p = i ;指向常量的常量指针，既不能改变*p的值，也不能改变p指向的对象

8.常量表达式
语法：
constexpr 数据类型 变量标识符 表达式
constexpr int a = 20;
在编译的时候，编译器会把表达式计算出结果，将值赋给常量表达式，如果在编译时，不能计算出常量结果，则会报错
constexpr定义一个指针时，不能把函数体内的值赋给指针，因为函数体内的变量地址不是固定的，但是函数体的时固定的
 